\subsection{Дополнительные обозначения}
\begin{enumerate}
    \item $D= \left( d_1, d_2, \dots, d_l \right)$, где $l$ - количество вершин, доступных для добавления(т.е. у которых нет предшественников в исходном графе) - множество вершин, доступных для добавления в расписание.
    \item $k$ - вектор длин критических путей от "головной" вершины до каждой вершины графа.
    \item $\left( s_i, p_i \right)$ - достаточное количество информации для размещения работы в расписании.
\end{enumerate}
Жадные критерии
\begin{enumerate}
    \item $GR1$ - критерий, используемый в выборе работы на постановку
    \item $GR2$ - критерий, используемый в выборе места постановки работы
\end{enumerate}
Процедуры ограниченного перебора
\begin{enumerate}
    \item $H1$ - процедура перебора для создания места для постановки работы
    \item $H2$ - процедура перебора для приближения времени старта работы к длине критического пути до нее
\end{enumerate}

\subsection{Словесное описание алгоритма}
\begin{enumerate}
    \item Сформировать множество вершин, у которых нет предшественников. Множество $D = \left( d_1, d_2 \dots d_i \right)$ где $d_i$ – номер работы, доступной для добавления в расписание (т.е. у которой нет предшественников в исходном графе)
    \item В случае, если в множестве $D$ одна вершина – обозначим ее за $d$, в противном случае – создадим фиктивную вершину с нулевой длительностью, у которой все потомки будут из множества $D$, и обозначим ее за $d$
    \item Зададим вектор $k$ – вектор длин критических путей до вершин от $d$. При помощи алгоритма Дейкстры этот вектор заполняется значениями $k_i$, где $i$ – номер вершины. Поскольку алгоритм Дейкстры работает со взвешенными графами, каждое ребро получает вес минимального времени работы на вычислительной системе вершины, из которой исходит
    \item По жадному критерию выбора работы выбирается работа из множества $D$ для размещения в расписании. Пусть выбранная работа – $d_i$
    \item Производится пробное размещение работы $d$ в расписании с учетом жадного критерия выбора места работы и дополнительных ограничений. В случае, если не получилось найти подходящее место для работы – запускается процедура ограниченного перебора с проверяемым критерием возможности добавления работы в расписание. Становится известно $s$ – время старта работы и $p$ – процессор, на котором работа выполняется. Выбор места выполнения работы происходит по системе допусков. Изначально места ранжируются по жадному критерию и берутся верхние $n\%$ (n – параметр алгоритма) списка. Оставшиеся места ранжируются по первому дополнительному ограничению, после чего снова берутся верхние $n\%$, и так далее по всем ограничениям. После прохода по всем ограничениям, из оставшегося списка берется место в соответствии с жадным критерием
    \item Если $s_i$ больше длины критического пути (с точностью до $\Delta$, где $\Delta$ – параметр алгоритма), то вызывается процедура ограниченного перебора с проверяемым критерием $S = \sum s_k$, где $s_k$ – времена начал всех перебираемых работ, в результате которой работа размещается в расписании. Если работу разместить не удалось – завершить алгоритм. Если $s_i$ не превосходит длину критического пути(с точностью $\Delta$), то работа размещается в расписании.
    \item $d_i$ удаляется из списка размещенных работ и в графе $G$ удаляется соответствующая вершина и все дуги, исходящие из нее.
    \item Обновляется множество $D$. Если $D$ не пустое, то алгоритм переходит на пункт 4.
\end{enumerate}
\subsubsection*{Жадный критерий выбора работы}
\begin{itemize}
    \item Максимальное количество потомков у работы
\end{itemize}
\subsubsection*{Жадный критерий выбора места работы в расписании}
\begin{itemize}
    \item Скорейшее завершение частично построенного расписания
\end{itemize}
\subsubsection*{Ограниченный перебор}
После неудачной пробной постановки работы в расписание алгоритм создает набор $K = \left( k_1, k_2, \dots, k_t \right)$, состоящий из $t$ последних добавленных работ ($t$ – параметр алгоритма). Далее, процедурой полного перебора пробуются различные расписания до тех пор, пока не получится расписание, удовлетворяющее критерию критичности пути до последней поставленной работы и удовлетворяющее дополнительным ограничениям.
\subsubsection*{Расчет времени начала работы}
Для того, чтобы рассчитать время начала  для конкретной работы на процессоре $p$ требуется:
\begin{enumerate}
    \item Вычислить вектор $PJ_{k=1}^L$, где $L$ – количество предшественников у работы. Элементами этого вектора будут являться суммы вида $s_k + C_{kr} + D_{rj}$, где $r$ – номер процессора, на котором размещен предшественник.
    \item Максимумом этого вектора и будет являться первое доступное начало выполнения работы на данном процессоре. $n_j=\max{PJ}$
\end{enumerate}

\subsection{Блок-схема алгоритма}
{\small
    \tikzfig{main-block-schema}
}