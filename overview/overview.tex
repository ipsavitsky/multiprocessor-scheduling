\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}

\addbibresource{biblio.bib}

\title{Обзор по задаче 1}

\setlength{\parindent}{20pt}

\begin{document}
\maketitle
\newpage
\section*{Оглавление}
\tableofcontents
\newpage
\section{Введение}
Целями данного обзора являются: рассмотрение различных алгоритмов, решающих задачу построения многопроцессорного расписания минимальной длительности и выделение классов алгоритмов с учетом математических постановок задач из области исследования 1 и классов исходных данных для задач из области исследования 1. \par
Рассматриваемая задача построения многопроцессорного расписания минимальной длительности принадлежит к классу NP-hard, так как является частным случаем классической NP-hard задачи построения списочного расписания \cite{Shakhbazyan_1981}. Для задач из класса NP-hard не существует полиномиальных алгоритмов, оптимально решающих задачу. Однако, для некоторых задач из NP-hard удается разработать псевдополиномиальные алгоритмы. На практике часто используют приближенные полиномиальные алгоритмы либо алгоритмы, специализированные под конкретные классы входных данных.\par
Алгоритмы построения многопроцессорных расписаний можно разделить на два класса, различающихся по используемым методам построения расписаний:
\begin{enumerate}
  \item \textit{Конструктивные алгоритмы.} Алгоритмы этого класса начинают процесс построения расписания с пустого расписания, не содержащего работ, а затем на каждом шаге добавляют работы в расписание.
  \item \textit{Итерационные алгоритмы.} Такие алгоритмы работают с полным расписанием (содержащим все работы). На каждом шаге такие алгоритмы изменяют расписание (при этом расписание остаётся полным), последовательно приближаясь к оптимальному решению.
\end{enumerate}
Можно выделить следующие классы конструктивных алгоритмов:
\begin{itemize}
  \item алгоритмы, основанные на нахождении максимального потока в транспортной сети;
  \item алгоритмы, основанные на методе ветвей и границ;
  \item алгоритмы, основанные на методе динамического программирования;
  \item алгоритмы, построенные на жадной схеме.
\end{itemize}
Можно выделить следующие классы итерационных алгоритмов:
\begin{itemize}
  \item генетический алгоритм
  \item дифференциальная эволюция
  \item алгоритм имитации отжига
  \item алгоритм муравьиных колоний
\end{itemize}
Далее будут сформулированы критерии обзора, и согласно этим критериям приведены описания всех классов алгоритмов, представленных выше.
\newpage

\section{Критерии обзора}

Ниже приведены критерии, по которым будут рассматриваться и сравниваться алгоритмы.
\begin{enumerate}
  \item Отличие решаемой алгоритмом задач из области исследований
  \item Сложность адаптации алгоритма к решаемой задаче.
  \item Алгоритм итерационный или конструктивный.
  \item Алгоритм является рандомизированным или детерминированным.
  \item Порядок сложности алгоритма, возможность масштабируемости алгоритма на данные большой размерности.
  \item На данных какой размерности протестирован алгоритм. Качество полученного результата. Время работы на протестированных данных.
\end{enumerate}
\newpage


\section{Конструктивные алгоритмы}
\subsection{Алгоритмы, основанные на нахождении максимального потока в сети}
Алгоритмы построения многопроцессорных расписаний, основанные на нахождении максимального потока в транспортной сети \cite{MaxFlowProblem} предполагают сведение задачи построения расписания к задаче поиска максимального потока в сети. На основе набора рабочих интервалов, процессоров, и ограничений исходной задачи (например, директивных сроков) строится сеть. Затем, для построенной сети решается задача поиска максимального потока, после чего, по построенному потоку в сети восстанавливается многопроцессорное расписание. Данный метод построения хорошо описан в литературе \cite{Stone_1977}, однако общим свойством задач, для которого он может применяться, является допустимость прерывания работ. В данной работе рассматривается задача построение расписаний, не допускающая прерывания выполнения рабочих интервалов, поэтому алгоритмы, основанные на нахождении максимального потока в сети неприменимы.

\subsection{Алгоритмы, основанные на методе динамического программирования}
Алгоритмы, основанные на методе динамического программировании \cite{Bellman_1966}, требуют введения двух операций:
\begin{enumerate}
  \item вложение решаемой задачи в семейство более простых задач;
  \item нахождение возвратного соотношения, связывающего оптимальные значения этих подзадач.
\end{enumerate}
Данные алгоритмы позволяют получить глобальный оптимум, но при этом для большинства задач комбинаторной оптимизации имеют не полиномиальную сложность. В частности, для NP-трудных задач построения расписаний \cite{Held_Karp_1962} сложность алгоритмов – факториальная функция от размера входа (число процессов, число рабочих интервалов и мощность множества исходного отношения частичного порядка). Более того, нахождение возвратного соотношения, связывающего оптимальные значения подзадач требует наличия аналитической модели вычислительной системы. Таким образом, данный алгоритм оказывается неприменим по Критерию 4 \textit{Порядок сложности алгоритма}.

\subsection{Алгоритмы, основанные на методе ветвей и границ}
Алгоритмы, основанные на методе ветвей и границ \cite{Lawler_Wood_1966}, используют разделение пространства возможных решений (представление в форме некоторого разветвления), верхнюю/нижнюю оценку значения целевой функции для выделенных областей и отсечение областей в которых нет оптимального решения. Данные алгоритмы позволяют получить глобальный оптимум, но при этом для большинства задач комбинаторной оптимизации имеют не полиномиальную сложность (в частности, для NP-трудных задач составления расписаний) сложность алгоритмов – факториальная функция от размера входа. Метод ветвей и границ позволяет строить алгоритмы, получающие решения с заданной точностью, но при этом верхняя оценка сложности алгоритма зависит от значений входных данных. Возможно и обратное: построение алгоритмов для решения NP-трудных задач, верхняя оценка которых является полиномиальной функцией от размера входа, но точность получаемого решения при этом зависит от значений входных данных. Данные подходы позволяют строить более сложные эвристики, точность которых в ограниченном диапазоне входных данных может быть выше, чем у эвристик, основанных на жадных стратегиях.\par
Метод ветвей и границ применялся для решения рассматриваемой задачи в ряде исследований \cite{Kasahara_1984, Kramer_1997, Fujita_2011}, однако из-за высокой сложности алгоритма рассматривались только небольшие графы задач с количеством вершин не более 1000.

\subsection{Жадные алгоритмы}
Жадные алгоритмы подразумевают декомпозицию задачи на ряд более простых подзадач. На каждом шаге решение принимается исходя из принципа получения оптимального решения для очередной подзадачи. То есть, на каждом шаге алгоритм делает выбор, оптимальный с точки зрения получения решения очередной подзадачи, предполагая, что эти локально-оптимальные решения приведут к приемлемому решению задачи. Какие-либо жадные стратегии, гарантированно получающие оптимальное расписание, на настоящий момент времени неизвестны, за исключением небольшого числа вариантов задач составления расписаний не принадлежащих к классу NP-полных. Например, известен жадный алгоритм, получающий точное решение для задачи обслуживания одним процессором максимального числа работ из заданного набора работ с фиксированными сроками начала и окончания \cite{Kormen_2001}. Набор локальных критериев оптимизации сильно зависит от класса архитектуры. Для архитектур, в которых возможно последействие (распределяемый в расписание рабочий интервал оказывает влияние на времена инициализации ранее распределенных рабочих интервалов) возникает проблема выбора локальных критериев оптимизации, позволяющих учесть эффект последействия (на настоящий момент времени какие-либо обоснованные решения этой проблемы не известны). Кроме того, единого локального критерия (или набора и способа их использования), приводящего к наилучшему конечному результату, для решения всех подзадач не существует. Более того, при усложнении архитектуры набор и способ использования локальных критериев оказывает более сильное влияние на конечный результат. Таким образом, применение жадных алгоритмов для составления расписаний классом архитектур без последействия или даже без разделяемых ресурсов, если их влияние на значение функции построения временной диаграммы не может быть локализовано, а также проблемой выбора критериев оптимизации индивидуально для каждой подзадачи.

\subsection{Жадные алгоритмы с процедурой ограниченного перебора}
Жадные алгоритмы в чистом  виде применяются редко из-за того, что в результате их работы часто получаются решения очень далекие от оптимальных, так как они склонны застревать в локальных минимумах оптимизирующей функции. Для того чтобы исправить этот недостаток был предложен подход \cite{Kostenko_2017}, сочетающий жадные алгоритм и ограниченный перебор. \par
Для решения задачи построения многопроцессорного расписания был предложен алгоритм на основе этого подхода \cite{Kostenko_2017}, состоящий из следующих шагов:
\begin{enumerate}
  \item Создание множества "доступных" работ (работы без "родителей" или работы, родители которых уже появились в расписании).
  \item Выбор работы из пула согласно жадному критерию $C1$ – максимальное количество потомков.
  \item Выбор и размещение работы в расписании с учетом жадного критерия $C2$: работа с ближайшим временем завершения.
  \item Проверки критериев:
        \begin{enumerate}
          \item Путь не критический
          \item В расписании нет простоев
        \end{enumerate}
  \item В случае выполнения критериев a)-b), выбирается следующая работа – перейти к пункту $1$ и обновить множество "доступных" работ.
  \item Иначе обратить внимание на работы, которые образуют простой и/или время не равно времени критического пути и переставить их ближе к началу (родительские работы – в первую очередь). Это часть ограниченного перебора. В случае невыполнения условий, можно повышать "глубину" ограниченного перебора. В случае, если в какой-то конфигурации все условия будут выполнены - перейти к п.1
\end{enumerate}
В основу предлагаемых в работе алгоритмов, сочетающих жадные стратегии и ограниченный перебор, положены следующие основные принципы:
\begin{itemize}
  \item на каждом шаге работы алгоритма делается локально-оптимальный выбор в соответствии с используемыми жадными критериями,
  \item на каждом шаге производится проверка того, что "жадный выбор не закрывает пути к оптимальному решению",
  \item вызов процедуры ограниченного перебора, если проверка условия «жадный выбор не закрывает пути к оптимальному решению» дала отрицательный результат.
\end{itemize}
Предложенный метод построения алгоритмов сочетающих жадные стратегии и ограниченный перебор дает возможность задавать требуемый баланс между точностью и сложностью алгоритма путем выбора значения максимально допустимой глубины перебора. Метод допускает настройку на частную задачу путем подбора жадных критериев. \par
В разобранном в статье \cite{Kostenko_2017} алгоритме рассматривается классический вариант задачи построения многопроцессорного расписания без учета дополнительных критериев, однако эти критерии легко учитываются как дополнительные условия при проверке оптимальности текущего расписания, построенного жадным алгоритмом, пункт 4 алгоритма. Более подробно про учет дополнительных условий см. раздел "Схемы выбранных алгоритмов".\par
Этот алгоритм детерминирован и имеет единственный его параметр – глубину перебора в процедуре ограниченного перебора. При установке малой глубины перебора можно создать неточное, но верное начальное приближение расписания для других алгоритмов, например для генетических алгоритмов, имитации отжига или дифференциальной эволюции. Притом, алгоритм конструктивен, нет потребности задания критерия останова алгоритма. \par
В краевом случае, когда все задачи распределяются в соответствии с жадными критериями и процедура ограниченного перебора не вызывается алгоритм имеет сложность $O(n\log{n})$ \par
Достоинства:
\begin{enumerate}
  \item Возможность балансировать между точностью и сложностью благодаря изменению глубины перебора.
  \item Не зависит от начальных условий, т.к. алгоритм детерминированный.
  \item Возможность получить расписание для поддерева работ.
\end{enumerate}
Недостатки:
\begin{enumerate}
  \item Необходимо подбирать жадные критерии в ходе эксперимента.
  \item Время работы алгоритма может быть большим, если процедура ограниченного перебора будет вызываться слишком часто.
\end{enumerate}
\newpage
\section{Итерационные алгоритмы}
\subsection{Генетические алгоритмы}
\subsubsection{Описание подхода}
Генетические алгоритмы (ГА), благодаря своей эффективности, применяются для решения таких задач, как построение оптимальных игровых стратегий, настройка и обучение нейронных сетей, оптимизация запросов в базах данных, построение расписаний \cite{Kostenko_2013, Kostenko_2000}, различные задачи на графах (раскраска, задача коммивояжера, нахождение паросочетаний), машинного обучения \cite{Kost_Scher_2013} и многих других. Но при построении ГА для решения конкретной задачи требуется решить ряд проблем \cite{Kostenko_2013}. Одной из таких проблем является выбор значений вероятностей операций мутации и скрещивания, которые оказывают сильное влияние на эффективность работы алгоритма. В настоящее время не существует никаких теоретических результатов, позволяющих решить эту проблему. В большинстве практических применений генетических алгоритмов значения параметров операций скрещивания и мутации подбираются экспериментально. Однако, для решения данной проблемы был предложен генетический алгоритм с самообучением \cite{Kostenko_2015}, основная идея которого заключается в изменении вероятностей скрещиваний и мутаций, в зависимости от того насколько удачным или неудачным оказалось применение конкретной операции (скрещивания или мутации) к элементу решения.\par
Генетические и эволюционные алгоритмы основаны на использовании механизмов естественной эволюции. Эволюция осуществляется в результате взаимодействия трех основных факторов: изменчивости, наследственности, естественного отбора. Изменчивость служит основой образования новых признаков и особенностей в строении и функциях организма. Наследственность закрепляет эти признаки. Естественный отбор устраняет организмы, плохо приспособленные к условиям существования. Генетические и эволюционные вычисления получили общее признание после выхода книги Джона Холланда “Адаптация в естественных и искусственных системах” \cite{Holland_1975} \par
Приведем схему классического генетического алгоритма Джона Холланда:
\begin{enumerate}
  \item Генерация случайным образом начальной популяции.
  \item Вычисление функции выживаемости для каждой строки популяции.
  \item Выполнение операции селекции.
  \item Выполнение операции скрещивания:
        \begin{enumerate}
          \item Выбор пары для скрещивания.
          \item Для каждой выбранной пары:
                \begin{enumerate}
                  \item с заданной вероятностью выполняется скрещивание – в результате создаются два потомков;
                  \item замена в популяции родителей на их потомков.
                \end{enumerate}
        \end{enumerate}
  \item Выполнение операции мутации.
  \item Если критерий останова не достигнут, перейти к шагу 2, иначе завершить работу алгоритма.
\end{enumerate}
Популяцией называется множество битовых строк, каждая из которых представляет в закодированном виде одно из возможных решений задачи. По битовой строке может быть вычислена функция выживаемости, которая характеризует качество решения. В качестве начальной популяции может быть использован произвольный набор битовых строк. Основные операции алгоритма - селекция, скрещивание и мутация - выполняются над элементами популяции. Результатом их выполнения является очередная популяция. Данный процесс продолжается итерационно до тех пор, пока не будет достигнут критерий останова.
\subsubsection{Алгоритм построения многопроцессорного расписания}
В качестве иллюстрации применения генетического алгоритма для решения задачи построения многопроцессорного расписания была рассмотрена работа \cite{Mehdi_2015}. В ней рассматривается задача построения многопроцессорных расписаний в следующей формулировке. Дан ориентированный ациклический граф, задающих порядок выполнения работ. Для каждого ребра определено время передачи данных между двумя работами, если они назначены на различные процессоры. Для работ, находящихся на одном процессоре время передачи данных равно нулю. Так же задано время выполнения каждой работы на процессорах. Требуется минимизировать время работы расписания. \par
В данной постановке время передачи данных задано между работами в отличие от обобщенной задачи 1, в которой рассматривается время передачи между процессорами. Также в \cite{Mehdi_2015} не рассматриваются процессоры, между которыми невозможна прямая передача данных. Отличие же от задачи $1$ состоит еще и в том, что в статье не рассматриваются дополнительные ограничения на долю межпроцессорных передач и несбалансированность распределения по процессорам. Схема генетического алгоритма представлена выше. \par
\textit{Алгоритм:}
\begin{enumerate}
  \item Генерация начальной популяции случайным образом.
  \item Вычисление функции выживаемости для каждой строки популяции.
  \item Выполнение операции селекции.
  \item Выполнение операции скрещивания.
  \item Выполнение операции мутации.
  \item Выполнение операции селекции.
  \item Выполнение операции инверсии.
  \item Выполнение операции скрещивания.
  \item Пока число популяций не достигло предела, вернуться на шаг 2.
\end{enumerate}
Граф зависимостей можно представить в виде ярусно-параллельной форме (ЯПФ)\\
Ярусно-параллельная форма графа - деление вершин ориентированного ациклического графа на пронумерованные подмножества $V_i$ такие, что, если дуга $e$ идет от вершины $v_1\in V_j$ к вершине $v_2\in V_k$, то обязательно $j < k$. \par
Каждое из множеств $V_i$ называется ярусом ЯПФ, $i$ - его номером, количество вершин в ярусе - его шириной. Количество ярусов в ЯПФ называется её высотой, а максимальная ширина её ярусов — шириной ЯПФ. Для ЯПФ графа алгоритма важным является тот факт, что операции, которым соответствуют вершины одного яруса, не зависят друг от друга, и поэтому заведомо могут быть выполнены параллельно на разных устройствах вычислительной системы. Минимальной высотой всех возможных ЯПФ графа является его критический путь. Построение ЯПФ с высотой, меньшей критического пути, невозможно. \par
Расписание представляется в виде хромосомы - двумерного массива, в первой строке которого расположены работы в порядке их выполнения, а во второй - процессоры, на которых выполняются соответствующие работы. \par
Вершины графа работ находятся в одном ярусе, если их высота в ЯПФ одинакова. Расписание в виде хромосомы представлен на Рис. №.., Фрагменты хромосом с разным цветом соответствуют разным ярусам в ЯПФ. \par
Начальная популяция генерируется таким образом, чтобы назначить работы из критического пути графа зависимостей на самый быстрый процессор. \par
Функция пригодности представителя популяции, которая используется в операции селекции - это функция, вычисляющая длительность расписания. \par
Во время селекции заранее заданный процент лучших представителей (который является параметром алгоритма, например, $10\%$) текущей популяции переходят в следующую популяцию. Остальные представители новой популяции выбираются из текущей случайно - чем выше их пригодность, тем выше вероятность выбора представителя. \par
При скрещивании выбираются два родителя и некоторый фрагмент хромосомы. В выбранном фрагменте у родителей меняются процессоры, на которые назначены работы, см. Рисунок №... \par
Мутация случайно меняет столбцы хромосомы внутри одного яруса ЯПФ. Инверсия обращает хромосому - переставляет работы внутри каждого яруса в обратном порядке. Обращение внутри яруса всегда возможно, так как работы не связаны друг с другом. В результате инверсии получается новая популяция обращенных хромосом, которая скрещивается с изначальной. \par
Для того, чтобы алгоритм был применим к задаче $1$, необходима коррекция функции пригодности с учетом связности процессоров и иного задания времени передачи данных. Одним из вариантов применения алгоритма к подзадачам с дополнительными ограничениями $\left( BF, CR, CR_2 \right)$ состоит в том, чтобы пересчитывать ограничения $BF, CR, CR_2$ после каждого применения операций (скрещивания и мутаций) и отменять изменения, если ограничения перестали выполняться. Другим вариантом может служить добавление штрафа в функцию пригодности при превышении критерия. При генерации начальной популяции также необходимо учитывать ограничения $BF, CR, CR_2$. \par
\textit{Экспериментальное исследование} \par
В ходе экспериментального исследования размер популяции устанавливался в 20 и 30, наибольшее число поколений – 1000. Эффективность сравнивалась с такими эвристическими алгоритмами, как: Modified Critical Path (MCP) \cite{Wu_1990}, Dynamic Critical Path (DCP) \cite{Kwok_1996}, Dominant Sequence Clustering (DSC) \cite{Yang_1994}, The Mobility Directed algorithm (MD) \cite{Wu_1990}. Размеры графов - 9-20 вершин, число процессоров - 2-6. Граф работ генерировался случайным образом. Результат алгоритма из \cite{Mehdi_2015} лучше, чем у всех перечисленных алгоритмов. \par
Сложность алгоритма $O\left( G \cdot \left( n + n^2 + n^2 + n^2 \cdot l + e \cdot m \right) \right)$, где $G$ - число положений, $n$ - число работ во входном DAG, $l$ - число ярусов в ЯПФ, построенной по графу работ, $e$ - число ребер в графе работ, $m$ - число процессоров. Для плотного графа, в котором число ребер сопоставимо с квадратом числа вершин, сложность составит $O\left( G \cdot n^2 \cdot m \right)$ \par
Результаты экспериментального исследования говорят о том, что алгоритм плохо масштабируется на данные большой размерности, так как при $n \sim 10^6, m \sim 10^3$ число операций становится велико даже без учета числа поколений, которое с ростом размера входа также должно увеличиваться. Это является основным недостатком генетического алгоритма. \par
число операций становится велико даже без учета числа поколений, которое с ростом размера входа также должно увеличиваться. Это является основным недостатком генетического алгоритма.
\newpage

\subsection{Дифференциальная эволюция}
\subsubsection{Описание подхода}
Рассмотрим конкретную реализацию алгоритма дифференциальной эволюции из работы \cite{Krzysztof_2005}. Расписание представляется вектором приоритетов: для каждой работы вычисляется приоритетность ее выполнения. При подсчете времени выполнения расписания из списка не назначенных работ берется та, у которой наибольший приоритет, и устанавливается на процессор так, чтобы время выполнения было наименьшим из возможных.
\begin{enumerate}
  \item Инициализация начальной популяции - $pop$
  \item Для каждого представителя популяции вычислить длительность расписания.
  \item $newPopulation = \emptyset$
  \item Для каждого представителя pop текущей популяции $i$:
        \begin{enumerate}
          \item Случайно выбрать $3$ различных представителя $r_1, r_2, r_3$.
          \item Создать потомка с приоритетами:
                \begin{gather*}
                  \underline{pr_{child}} = \underline{pr_i} + K \cdot \left( \underline{pr_{r_3}} - \underline{pr_i} \right) + F \cdot \left( \underline{pr_{r_1}} - \underline{pr_{r_2}} \right)
                \end{gather*}
          \item Для потомка применить корректировку приоритетов и нормализовать их.
          \item Посчитать длину расписания потомка $makespan_{child}$
          \item Если $makespan_{child} < makespan_i$, то включить потомка в новую $newPopulation$. \par
                Иначе включить представителя $i$ в $newPopulation$.
        \end{enumerate}
  \item $pop = newPopulation$.
  \item Пока число популяций не достигло заранее заданного предела, вернутся на шаг 3.
\end{enumerate}
Для первой части начального поколения списки приоритетов вычисляются с помощью различных приближений. Оставшаяся часть начального поколения генерируется случайно. \par
Для каждой работы производится коррекция приоритетов в соответствии с графом зависимостей - увеличиваются приоритеты у работ, предшественники которых имеют более высокий приоритет. \par
В работе \cite{Krzysztof_2005} вычислительная система представлена в виде графа, вершинами которого являются процессоры. Дан ациклический граф зависимостей работ. Для каждой пары работ, соединенных ребром, задано время передачи данных, если они назначены на различные процессоры. Работы выполняемые на одном процессоре имеют нулевое время передачи данных. Полное время передачи данных вычисляется как произведение времени передачи данных между работами и кратчайшего пути между соответствующими процессорами.\par
Задача, рассматриваемая в \cite{Krzysztof_2005} близка к рассматриваемой задаче 1. Одно из отличий заключается в задании времени передачи данных между работами. Для сведения задачи из \cite{Krzysztof_2005} к рассматриваемой задаче 1 необходимо изменить соответствующим образом функцию вычисления длительности расписания. \par
В \cite{Krzysztof_2005} не рассматриваются дополнительные ограничения задачи 1. Однако, можно поступить аналогичным образом как и в генетическом алгоритме. Либо добавить штраф при вычислении длительности расписания, либо не добавлять потомков, которые не удовлетворяют ограничениям $BF, CR, CR_2$. \par
Сложность алгоритма зависит от размера популяции и количества поколений. Также зависит от функции вычисления длительности расписания, Для нее в статье указана сложность $O\left( N \cdot \log{N} \right)$, где $N$ - число вершин графа. \par
\textit{Экспериментальное исследование}
В работе \cite{Krzysztof_2005} было проведено два экспериментальных исследования. Первое заключалось в сравнении качества получаемого решения алгоритмом дифференциальной эволюции с генетическим алгоритмом при одинаковом числе поколений и размере популяции. Методика проведения сравнения алгоритмов заключалась в следующем. Генерировалось начальная популяция - начальное приближение расписания. Далее запускался генетический алгоритм и алгоритм дифференциальной эволюции и после завершения их работы сравнивались полученные ими расписания по длительности. По результатам сравнения генетический алгоритм улучшал расписание на $1-2\%$, а алгоритм из \cite{Krzysztof_2005} давал улучшение в $4-5\%$. \par
Было проведено второе экспериментальное исследование, которое оценивало способность сходимости алгоритма к глобальному оптимуму. Для фиксированного набора входных данных – графа зависимостей работ в виде DAG и графа процессоров – генерировалось оптимальное расписание. Предложенный алгоритм строил расписание на $3\%$ длиннее, чем оптимальное. \par
Первое экспериментальное исследованием проводилось на графах различной плотности с $50-500$ вершинами. Второе экспериментальное исследование проводилось на графах с $50-200$ вершинами. При количестве поколений $50$ и размере популяции $24$ время работы алгоритма в среднем составляло $11$ секунд. \par
Выводом из экспериментальных исследований из \cite{Krzysztof_2005} является тот факт, что дифференциальная эволюция может работать быстрее генетического алгоритма и давать лучшие результаты. Однако оценки сложности алгоритма и время его работы на небольших данных могут говорить о плохой масштабируемости алгоритма на графы большой размерности, что важно в исследуемой задаче 1.
\newpage

\subsection{Алгоритм имитации отжига}
\subsubsection{Описание подхода}
Алгоритм имитации отжига – это стохастический метод, предложенный в 1983 \cite{Kirkpatrick_1983}. Алгоритм имитации отжига хорошо себя зарекомендовал в решении задачи о назначении работ на многопроцессорную вычислительную систему \cite{Yskandar_2000}, задачах управления \cite{Yang_2021}, задаче распределения работ по процессорам для обеспечения максимальной надежности вычислительной системы \cite{Gamal_2006}, задаче построения расписания спортивных игр \cite{Rosati_2021}, также в задачах машинного обучения \cite{Shih-Wei_2008} \par
В тоже время использование алгоритма имитации отжига позволяет получать хорошие приближенные решения для целого ряда NP-трудных задач комбинаторной оптимизации. Принципы работы алгоритма имитации отжига описаны в \cite{Wasserman_1988}.

\subsubsection{Алгоритм построения многопроцессорного расписания}
В работе \cite{Kalashnikov_2008} рассматривается задача наиболее близкая к задаче 1: задача минимизации времени выполнения расписания. На входе дан ориентированный граф зависимостей работ. Для каждой работы известна ее вычислительная сложность на процессорах системы. \par
Первое отличие от задачи 1 - отсутствие затрат на передачи данных, вследствие чего необходима коррекция целевой функции в соответствии с этим. Второе отличие состоит в том, что не рассматриваются ограничения на межпроцессорную передачу и балансировку. Учесть это в задаче 1 можно аналогичными способами, предложенными в генетическом алгоритме. \par
\textit{Схема алгоритма имитации отжига выглядит следующим образом:}
\begin{enumerate}
  \item Генерация корректного начального расписания.
  \item Установление начальной температуры $T_0$.
  \item Применение операции преобразования расписания.
  \item Если изменение целевой функции $\Delta f \leq 0$ (т. е. расписание улучшилось), то новый вариант расписания считать текущим.
        Иначе принять новое расписание в качестве текущего с вероятностью $p = e^{\frac{-\Delta}{T}}$, где $T$ - текущая температура.
  \item Повторить заданное число раз шаги 3 и 4 без изменения текущей температуры.
  \item Повысить текущую температуру в соответствии с выбранным законом.
  \item Если не выполнен критерий останова, то перейти к шагу 3.
\end{enumerate}
Расписание представляется в виде ярусной формы максимальной высоты. В ней на ярусе расположена ровно одна работа, причем все работы-предшественники расположены на более высоких ярусах. \par
Допускается любая генерация начального расписания. В \cite{Kalashnikov_2008} в качестве начального расписания взято расписание, генерируемое жадным алгоритмом. Режим понижения температуры задан законом Больцмана $T = \frac{T_0}{\ln{1+i}}$, где $T_0$ - начальная температура, $i$ - номер текущей итерации. Критерием останова может служить ограничение на число итераций или отсутствие улучшение расписания заданное число шагов. \par
Применяется две операции преобразования: перенос работы на другой процессор и смена порядка работ на одном процессоре. Сложности операций $O(1)$ и $O(N)$ соответственно, где $N$ - число работ. \par
Основной недостаток алгоритма имитации отжига заключается в его высокой вычислительной сложности, так как для нахождения хорошего решения требуется медленное понижение температуры, что приводит к увеличению итераций. Для решения этой проблемы в статье был предложен оригинальный метод распараллеливания алгоритма, основанный на разбиении на непересекающиеся области. \par
В области поиска (изначально исходное пространство расписаний) выбираются две работы таким образом, чтобы они не были связаны транзитивным отношением порядка. Из этого графа получается 3 области поиска:
\begin{itemize}
  \item работы распределены на разные процессоры;
  \item работы распределены на один процессор, и вторая работа выполняется после первой;
  \item работы распределены на один процессор, и первая работа выполняется после второй.
\end{itemize}
Работы выбираются так, чтобы критические пути графов в получившихся областях сильно отличались. Это может позволить отбросить области с заведомо долгими расписаниями. \par
Области распределяются между узлами вычислительной системы, на которой запускается алгоритм. На узлах отдельно выполняются последовательные алгоритмы имитации отжига для областей и отбрасываются те, время работы которых сильно отличается от остальных. Раз в определенный промежуток времени между узлами происходит обмен, чтобы отсечь области, которые имеют сильно отличающиеся времена выполнения расписаний. \par
Дополнительным преимуществом данного параллельного подхода может служить то, что он не требует высокого трафика обмена между вычислительными узлами. \par
\textit{Экспериментальное исследование}\par
Экспериментальное исследование проводилось на следующих входных данных: ориентированные графы работ с $100-250$ вершинами, рассматривались графы различной плотности, количество процессоров - $40-100$. Предложенные в работе \cite{Kalashnikov_2008} последовательный и параллельный алгоритмы имитации отжига, использующие разбиение пространства решений на области, показали высокую эффективность при решении задач построения многопроцессорных расписаний. Последовательный алгоритм позволяет уменьшить время решения задачи до 3 раз по сравнению с классическим алгоритмом имитации отжига, сохраняя, а во многих случаях даже улучшая качество получаемых решений. Параллельный алгоритм может быть эффективно реализован на многопроцессорном вычислителе или вычислительном кластере, состоящем из нескольких вычислительных узлов, поскольку не требует высокого трафика обмена между узлами сети. \par
Построение алгоритма имитации отжига, основанного на этом подходе, требует решения следующих проблем:
\begin{enumerate}
  \item Разбиение исходного пространства корректных решений на несколько областей, дающих в объединении все пространство.
  \item Выбор начального корректного решения  в каждой из областей.
  \item Введение операций преобразования решения таким образом, чтобы они были замкнуты в каждой из областей.
  \item Выбор способа распределения областей по узлам вычислительной системы и схемы отсечения "неперспективных" областей в ходе работы алгоритма.
\end{enumerate}
\newpage

\section{Алгоритм муравьиных колоний}
\subsection{Описание подхода}
Муравьиные алгоритмы, или алгоритмы муравьиных колоний основаны на принципах взаимодействия муравьев в естественной среде, а именно на их роевом интеллекте. Каждый отдельный муравей обладает информацией только о локальной обстановке, ни один из них не имеет представления обо всей картине в целом,  только то, что узнал от другим муравьев явно или неявно. На неявных взаимодействиях муравьёв основаны механизмы поиска кратчайшего пути от муравейника до источника пищи. Каждый раз, проходя по такому пути, муравей оставляет за собой след из феромонов. Другие муравьи, почувствовав след из феромонов, будут инстинктивно устремляться к нему. Поскольку все муравьи оставляют за собой дорожки феромонов, то чем больше муравьев проходит по определенному пути, тем более привлекательным данный путь становится для всех муравьев. При этом, чем короче путь до источника пищи, тем меньше времени требуется муравьям на его преодоление, а следовательно, тем быстрее оставленные на нем следы становятся заметными. \par
Чтобы применить алгоритм муравьиных колоний к рассматриваемой задаче, необходимо представить задачу в терминах поиска пути в графе. Найденный путь и будет представлять решение задачи. Различные пути в графе – это пути, по которым перемещаются муравьи и оставляют свои феромоны. \par
Стандартная схема муравьиного алгоритма выглядит следующим образом:
\begin{enumerate}
  \item Задание начального количества феромонов на ребрах графа;
  \item Задание начального количества муравьев;
  \item Задание начального положения муравьев;
  \item Построение муравьями путей;
  \item Вычисление целевой функции для каждого пути;
  \item Обновление количества феромона на каждом ребре;
  \item Повторять шаги $1)-7)$ пока не будет выполнено условие останова (например, расписание построено – все работы размещены, критерии выполнены).
\end{enumerate}
\par Муравьиные алгоритмы нашли широкое применение в приближенном решении NP-трудных задач. Так в работах \cite{Bauer_2000} рассматривается задача минимизации суммарного запаздывания на одном процессоре. В Smitha\_2011 приведено описание сбалансированного алгоритма муравьиных колоний для планирования вычислений в GRID-системах. В \cite{Myszkowski_2015} рассматривается гибридный муравьиный алгоритм для проектного планирования при условии ограниченности ресурсов. Часто алгоритм муравьиных колоний показывает хорошие результаты, которые можно улучшить при помощи различных модификаций (например, локального поиска или правил исключения. В работе \cite{Gagne_2015} приводится сравнение алгоритма муравьиных колоний с различными метаэвристическими алгоритмами, в числе которых алгоритм имитации отжига и генетический алгоритм, и установлено, что для задач больших размерностей алгоритм муравьиных колоний показывает более лучшие результаты. \par
В работе \cite{Shtovba_2005} предложен алгоритм муравьиных колоний, решающий задачу коммивояжера. В ней показано, что предложенный алгоритм можно легко адаптировать для решения задачи построения многопроцессорного расписания. Для решения задачи 1 достаточно для каждого муравья отрезать пути, которые не удовлетворяют дополнительным ограничениям $BF, CR, CR_2$. \par
Таким образом, можно сделать вывод, что алгоритм муравьиных колоний является рандомизированным алгоритмом, на каждой вершине муравей выбирает какой-либо путь с определенной вероятностью. \par
Алгоритм итерационный: на каждой итерации строится новый путь каждого муравья и новое расписание. Муравьиный алгоритм получает ответ за большее время, однако может получать более качественное решение.
\subsubsection{Алгоритм построения многопроцессорного расписания}
\par В качестве конкретной реализации муравьиного алгоритма рассмотрим работу \cite{Kostenko_Plakunov_2017} Задача, первоначальная рассмотренная в статье сильно отличается от задачи 1, однако так же как и задача 1 сводится к задаче построения в графе работ пути минимальной длины. В \cite{Kostenko_Plakunov_2017} решается задача о размещении виртуальных машин $(V)$ и виртуальных хранилищ данных $(S)$ на вычислительные узлы таким образом, чтобы количество размещенных работ было максимальным.
\par Алгоритм, решающий данную задачу, выглядит следующим образом:
\begin{enumerate}
  \item Пусть $C$ - это граф, вершины которого представляют собой работы и вычислительные узлы.
  \item Все муравьи начинают путь из специальной начальной вершины $O$.
  \item Находясь в вершине $O$ первый раз, муравей выбирает одну вершину из $V_0^1,\dots ,V_0^R$ - множество виртуальных машин. После того как муравей прошел по всем вершинам $V_0^K$, он возвращается в вершину $O$ и выбирает одну вершину из $S_0^1,\dots , S_0^J$ - множество виртуальных хранилищ данных. Путь считается построенным когда муравей пройдет по всем вершинам $S_0^K$
  \item Выбирать вершины $V_1, \dots , V_N$ и $S_1, \dots , S_Q$ муравьям можно больше одного раза.
  \item Выбрав вершину, соответствующую $V_0^K$ или $S_0^K$, муравей обязан выбрать следующей вершину, соответствующую вычислительному узлу.
  \item Выбрав вершину, соответствующую вычислительному узлу, муравей обязан вернуться в вершину, из которой приш
\end{enumerate}
\par В контексте задачи, рассматриваемой в \cite{Kostenko_Plakunov_2017} виртуальные машины и виртуальный хранилища данных - это аналоги работ в задаче 1. А вычислительный узлы – это аналоги процессоров в задаче 1. \\
\textit{Экспериментальное исследование}
\par В \cite{Kostenko_Plakunov_2017} было проведено экспериментальное исследование  разработанного алгоритма на различных случайно сгенерированных наборах данных, разделенных на два класса. Результат работы алгоритма сравнивался с результатом работы генетического алгоритма.
\par Достоинства:
\begin{enumerate}
  \item Предложенный в \cite{Kostenko_Plakunov_2017} сравнительно эффективен при маленьком количестве вершин.
  \item Меньше подвержен начальному состоянию чем генетические алгоритмы.
  \item Может адаптироваться к изменению начальных условий, в отличии от генетических алгоритмов.
\end{enumerate}
\par Недостатки:
\begin{enumerate}
  \item Сходимость гарантируется, но время сходимости неопределено
  \item Все еще сильно зависит от начального состояния
\end{enumerate}
\newpage

\printbibliography
\end{document}