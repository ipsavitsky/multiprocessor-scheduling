\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{csquotes}
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}

\addbibresource{biblio.bib}

\title{Обзор по задаче 1}


\begin{document}
  \maketitle
  \newpage
  \section*{Оглавление}
  \tableofcontents
  \newpage
  \section{Введение}
  Целями данного обзора являются: рассмотрение различных алгоритмов, решающих задачу построения многопроцессорного расписания минимальной длительности и выделение классов алгоритмов с учетом математических постановок задач из области исследования 1 и классов исходных данных для задач из области исследования 1.\\
  Рассматриваемая задача построения многопроцессорного расписания минимальной длительности принадлежит к классу NP-hard, так как является частным случаем классической NP-hard задачи построения списочного расписания \cite{Shakhbazyan_1981}. Для задач из класса NP-hard не существует полиномиальных алгоритмов, оптимально решающих задачу. Однако, для некоторых задач из NP-hard удается разработать псевдополиномиальные алгоритмы. На практике часто используют приближенные полиномиальные алгоритмы либо алгоритмы, специализированные под конкретные классы входных данных.\\
  Алгоритмы построения многопроцессорных расписаний можно разделить на два класса, различающихся по используемым методам построения расписаний:
  \begin{enumerate}
    \item \textit{Конструктивные алгоритмы.} Алгоритмы этого класса начинают процесс построения расписания с пустого расписания, не содержащего работ, а затем на каждом шаге добавляют работы в расписание.
    \item \textit{Итерационные алгоритмы.} Такие алгоритмы работают с полным расписанием (содержащим все работы). На каждом шаге такие алгоритмы изменяют расписание (при этом расписание остаётся полным), последовательно приближаясь к оптимальному решению.
  \end{enumerate}
  Можно выделить следующие классы конструктивных алгоритмов:
  \begin{itemize}
    \item алгоритмы, основанные на нахождении максимального потока в транспортной сети;
    \item алгоритмы, основанные на методе ветвей и границ;
    \item алгоритмы, основанные на методе динамического программирования;
    \item алгоритмы, построенные на жадной схеме.
  \end{itemize}
  Можно выделить следующие классы итерационных алгоритмов:
  \begin{itemize}
    \item генетический алгоритм
    \item дифференциальная эволюция
    \item алгоритм имитации отжига
    \item алгоритм муравьиных колоний
  \end{itemize}
  Далее будут сформулированы критерии обзора, и согласно этим критериям приведены описания всех классов алгоритмов, представленных выше.
  \newpage

  \section{Критерии обзора}

  Ниже приведены критерии, по которым будут рассматриваться и сравниваться алгоритмы.
  \begin{enumerate}
    \item Отличие решаемой алгоритмом задач из области исследований
    \item Сложность адаптации алгоритма к решаемой задаче.
    \item Алгоритм итерационный или конструктивный.
    \item Алгоритм является рандомизированным или детерминированным.
    \item Порядок сложности алгоритма, возможность масштабируемости алгоритма на данные большой размерности.
    \item На данных какой размерности протестирован алгоритм. Качество полученного результата. Время работы на протестированных данных.
  \end{enumerate}

  \section{Конструктивные алгоритмы}
  \subsection{Алгоритмы, основанные на нахождении максимального потока в сети}

  \subsection{Алгоритмы, основанные на методе динамического программирования}

  \printbibliography
\end{document}